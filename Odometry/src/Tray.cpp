#include "Tray.h"
//constructer: input value goes into Max encoder value for angler
Tray::Tray(float in)
{
  stackMax = in;
}
void Tray::iterateStack(float kP,float kI, float kD){
  //see pid.h
  static PID TrayControl = {kP,kI,kD};
  float err = stackMax - Stacker.position(rotationUnits::deg);
  //the speed generated by the PID loop
  float speed = TrayControl.GetValue(err);
  Stacker.spin(directionType::fwd,speed,velocityUnits::pct);
}
void Tray::stack(int timeout,float kP,float kI,float kD)
{
  isPIDRunning = true;
  //see pid.h
  PID TrayControl = {kP,kI,kD};
  
  for(int x = 0; x < timeout/10;++x){
    float err = stackMax - Stacker.position(rotationUnits::deg);
    //the speed generated by the PID loop
    float speed = TrayControl.GetValue(err);
    Stacker.spin(directionType::fwd,speed,velocityUnits::pct);
    task::sleep(10);
    if(fabs(err) < 0.1)
    {
      TrayControl.printFirstTime(x*10);
    }
  }
  isPIDRunning = false;
  Stacker.stop(brakeType::hold);
}

void Tray::retract(float speed)
{
  //retract until the button is pressed
  isPIDRunning = true;
  while(!Config.Limit.pressing()){
    Stacker.spin(directionType::rev, 127, percentUnits::pct);
    task::sleep(50);
  }
  stop();
  //reset the rotation
  reset();
  isPIDRunning = false;
}

float Tray::value(){
  return Stacker.rotation(rotationUnits::deg);
}

void Tray::reset(){
  Stacker.resetRotation();
}

void Tray::spin(int speed)
{
  if(!isRunning()){
    Stacker.spin(directionType::fwd,speed,velocityUnits::pct);
    reset();
  }
}

void Tray::stop(){
  if(!isRunning()){
    Stacker.stop(brakeType::hold);
  }
}

bool Tray::isRunning(){
  if(Stacker.isDone() && !isPIDRunning){
    return false;
  }
  return true;
}